---
content_title: Nested Containers
---

## Overview

This tutorial demonstrates the usage of various C++ nested-containers in smart contracts for the following EOSIO types:

* [Multi-Index Table](https://developers.eos.io/manuals/eosio.cdt/latest/how-to-guides/multi-index/index)
* [Key-Value Map](https://developers.eos.io/manuals/eosio.cdt/latest/how-to-guides/key-value-api/kv_map/index)

### The Nested-Containers Covered Are

This tutorial covers the following netsted-containers combinations.

* Single standard template library (STL) containers defined in the `std` namespace
    * std::vector
    * std::set
    * std::optional
    * std::map
    * std::tuple
    * std::pair which needs special attention for cleos input format
* Standard C++ structures
    * Simple struct
    * Complex struct
* Two-layers nested containers made of combinations of the following
    * std::vector
    * std::set
    * std::optional
    * std::map
    * std::tuple
    * std::pair
* One three-layers nested container for farther extentions demonstration

[[info | Note]]
| std::array, std::variant are not supporterd yet]]

### Cleos commands

In adition the cleos commands for various nested-containers are also documented. Specifically it shows how to emplace and how to retrieve data using cleos *get table* and *get kv_table*. The cleos commands are documented at the end of the two shell scripts which accompany this tutorial.

## Demo Source Files

The code source files and script files which accompany this tutorial are located in the [eosio.cdt](https://github.com/EOSIO/eosio.cdt/tree/develop) repository and are organized as follows: 

* The subdirectory *./nestcontn2a/* demonstrates the nested container support for `eosio::multi_index`
* The subdirectory *./nestcontn2kv/* demonstrates the nested container support for `eosio::kv::map`
* The *.abi* and *.wasm* files inside these two directories are generated by *eosio-cpp* compiler and are uploaded for reference
* The important *.cpp* files and *.sh* scripts inside these two subdirectories are:
  * The *./nestcontn2a/nestcontn2a.cpp* file which codes a contract `nestcontn2a` whose multi-index table `person2` has various containers
  * The *./nestcontn2a/tupletest/tupletest.cpp* file which codes a contract `tupletest` which shows the support for `std::tuple` for multi-index table `person2` by the new *eosio-cpp* compiler version
  * The *./nestcontn2kv/nestcontn2kv.cpp* file which codes a contract `nestcontn2kv` whose `eosio::kv::map` table wraps struct `person2kv` that has various containers and different types of keys
  * The *./nestcontn2kv/tupletestkv/tupletestkv.cpp* file which codes a contract `tupletestkv` which shows the support on `std::tuple` for `eosio::kv::map` table `person2kv` by the new *eosio-cpp* compiler version
* The *./nestcontn2a/doNestContainer.sh* file script which tests all cleos commands related to *nestcontn2a.cpp* and *tupletest.cpp*
* The *./nestcontn2kv/doNestContainerKV.sh* file script which tests all cleos commands related to *nestcontn2kv.cpp*  and *tupletestkv.cpp*

### How To Run The *.sh* Scripts

There are over 100 cleos commands related to the use of various nested-containers in total and they are listed in the comments of the *.cpp* files before each corresponding eosio action. Two *.sh* scripts are provided to facilitate the test and the verification of these cleos commands.

Before you run each of the two *.sh* scripts, you need to make sure your default wallet is unlocked, and replace EOS6...r2C with your own development key. In a development environment, you may need to restart nodeos.

Before you can use the *./nestcontn2kv/doNestContainerKV.sh*, you must run the *enable-kv.sh* script to enable the [KV_DATABASE protocol feature](https://developers.eos.io/manuals/eos/v2.1/release-notes/index/#key-value-tables-8223-9298) for the nodeos you intend to connect to. The *enable-kv.sh* script is located in the *eos/contracts/enable-kv/* subdirectory in the latest release of the eos repository.

Also it is important to read the comments placed at the beginning of the two *.sh* script files and follow those instructions as well. After you got through those preparation steps, execute the following two scripts in the root directory of your local repository on your bash console: 

```sh
./nestcontn2a/doNestContainer.sh
./nestcontn2kv/doNestContainerKV.sh
```

### Construct Suitable *.abi* Types

The *.abi* type of a C++ primitive type such as `uint16_t` it is defined by EOSIO as `uint16`, however the *.abi* types of containers and especially nested-containers must be carefully considered to make sure the corresponding user data can be pushed into the EOSIO block chain correctly via cleos commands and/or web APIs.

You can inspect the *.abi* types a C++ EOSIO contract defines and/or uses in its corresponding *.abi* file.

For example:

* The *.abi* type of `std::vector<uint16_t>` or `std::set<uint16_t>` is `uint16[]` and ends with `[]`
* The *.abi* type of `std::optional<uint16_t>` is `uint16?` and ends with `?` which means the allowed value is either `null` or `uint16_t`

Logically it follows that the *.abi* type of `optional<vector<uint16_t>>` is `uint16[]?`. However, if you define an action, in your C++ EOSIO contract code, which uses `optional<vector<uint16_t>>` directly as below: 

```cpp
[[eosio::action]] void setov(int id, const optional<vector<uint16_t>> &ov)
```

then the *eosio-cpp* compiler output on your contract looks good, but the following cleos command will fail:

```sh
cleos --verbose push action nestcontn2kv setov '[2, [1001,2001, 3001]]' -p alice@active
```

Above cleos command will output the following error message:

```text
Error 3015004: The type defined in the ABI is invalid*.
```

To solve the above problem, you should use `typedef` in your C++ contract code as below: 

```cpp
typedef vector<uint16_t> vec_uint16;
```

and then the corresponding eosio action should be written as:

```cpp
[[eosio::action]] void setov(int id, const optional<vec_uint16>& ov)
```

Now the same cleos command will work properly, and if you check the generated *.abi* file, you can notice the *.abi* type of `ov` parameter will be `vec_uint16?` instead of previous `uint16[]?`. Consult the *.cpp* files accompanying this tutorial for **more examples** on how to use `typedef` to successfuly create *.abi* types of nested-containers that work for cleos commands. 

[[info]]
| You can not create and use an *.abi* type of a variable which has two or more of each `[]` and `?` because it will cause a related cleos command error. If your nested-container types have more than one of each `[]` and `?` then you must use `typedef` to make sure the *.abi* type of the related container variable has at most one of each `[]` and `?`.

### About *std::pair* And *std::map* In Cleos Commands

In EOSIO code base, `std::pair` is a struct of fields *first* and *second*, `std::map` is regarded as an array/vector of structs with fields *key* and *value*, as observed in *.abi* files where `std::pair<uint16_t, uint16_t>` has *.abi* type
`pair_uint16_uint16`, and `std::map<uint16_t, uint16_t>` has *.abi* type `pair_uint16_uint16[]`.

However a container which is a combination of both `std::pair` and `std::map` may have a complex mixture of *key* and *value*, *first* and *second* which are documented in the *.sh* scripts, and in the comments of the *.cpp* files. Please pay special attention on the cleos commands of *setmm* for map of maps, *setmp* for map of pairs, *setpm* for pair of maps, and *setpp* for pair of pairs, because **the cleos commands of all these 4 actions use *"key"* and *"value"* with the *"value"* part embracing *"first"* and *"second"***. 

For example, *setm* only uses *key* and *value*, and *setp* only uses *first* and *second*, but *setmm* and *setpp* use *"key"* and *"value"* with the *"value"* part embracing *"first"* and *"second"* as below:

```sh
cleos push action nestcontn2kv setmm '[1, [{"key":10,"value":[{"first":200,"second":2000}, {"first":201,"second":2001}] }, {"key":11,"value":[{"first":300,"second":3000}, {"first":301,"second":3001}] } ]]' -p alice@active

cleos push action nestcontn2kv setpp '[1, {"key":30, "value":{"first":301, "second":302} }]' -p alice@active
```

The cleos commands of *setmp* and *setpm* follow the same pattern as shown in the *.sh* scripts of this project. Also, you should use it in the cleos commands whenever `std::pair` or `std::map` is nested with any other container such as *setvm* for vector of maps, *setvp* for vector of pairs etc., which are all documented in the two *.sh* scripts.

## Supported Nested-Containers

The following table describes which nested-containers combinations of STL set, vector, optional, map, pair and tuple in the std namespace are supported by current EOSIO implementation:

|     | set | vector | optional | map | pair | tuple |
| --- | --- | ---    | ---      | --- | ---  | ---   |
| set | supported | supported   | supported | supported | supported  | supported  |
| vector | supported | supported   | supported | supported | supported  | supported  |
| optional | supported | supported   | supported | supported | supported  | supported  |
| map | supported | supported   | supported | supported | supported  | supported  |
| pair | supported | supported   | supported | supported | supported  | supported  |
| tuple |  supported |  supported   |  supported |  supported |  supported  | supported  |

The above matrix is **applicable to** both **eosio::multi_index** and the **value part of eosio::kv::map**.
The **std::tuple is supported only in the new version of *eosio-cpp* compiler**, previous versions exhibit a bug related to parsing AST.

For example:

```cpp
using my_map_t = eosio::kv::map<"people2kv"_n, int, person2kv>
```

defines an `eosio::kv::map` type, which has `int` as its key, and struct `person2kv` as its value, and field `set<vec_uint16> stv` of its value part struct `person2kv` is a set of vectors; according to the first row of above table, set of vectors is *supported*, and the cleos commands of the related push actions *setstv, prntstv* are documented in the *.sh* scripts of this project.

### Additional Rules

* The **key part** of `eosio::kv::map` can be primitive types, e.g. `std::string`, `eosio::name`, which are all supported by current ESOIO implementation
* If the *key part* of `eosio::kv::map` is a self-defined struct, then the self-defined struct has to be wrapped by **CDT_REFLECT**, as shown in below, which can be found in *./nestcontn2kv/nestcontn2kv.cpp*:

    ```cpp
    using my_map_t4 = eosio::kv::map<"people2kv4"_n, mystructrefl, person2kv>
    ```

* The current EOSIO implementation does NOT yet support `set<optional<T>>` and `vector<optional<T> >`, because they cause issues in `cleos get table` and `cleos get kv_table` commands
* Strictly speaking, `std::pair` is just a struct of fields *first* and *second*, it is not an STL container. But `std::pair` is listed in the support table because of its complex cleos data input formats, especially when it is combined with `std::map` 

### How To Publishing A WASM File Bigger Than 512KB

This part is optional, read this part only if you want to know how to publish to nodeos a WASM file which is bigger in size than 512KB. 
You can add more eosio actions in *./nestcontn2kv/nestcontn2kv.cpp*, however once the generated *./nestcontn2kv/nestcontn2kv.wasm* is bigger than 512KB, publishing the .wasm into nodeos would fail, and it will show the following error *"Failed to connect to keosd"*. 

For example, if you add all the eosio actions of *./nestcontn2kv/tupletestkv/tupletestkv.cpp* into *./nestcontn2kv/nestcontn2kv.cpp* you will get a bloated *nestcontn2kv.cpp*. The generated *nestcontn2kv.wasm* would be bigger than 512KB, and as a consequence you will fail if you publish the .wasm file to nodeos using the default options of nodeos and keosd. To succeed the **max-body-size** option of keosd and the **max-body-size** option of nodeos have to be modified, like it is shown in the example below:

```shell
ps aux |grep nodeos
pkill nodeos

ps aux |grep keosd
pkill keosd

# use vim to edit ~/eosio-wallet/config.ini, modify the default size of max-body-size as below and save config.ini
  # max-body-size = 1048576
  max-body-size = 1000000000
  
cleos wallet list
  # Above command will restart keosd, which can be verified from 'ps aux |grep keosd'
  
cleos wallet open
cleos wallet unlock
  # Enter your private key for your Default wallet
  
nodeos --max-body-size 1000000000  --blahlah
  # Above restarts nodeos with its max-body-size set as 1000000000
  
cleos --verbose set contract nestcontn2kv ./ -p nestcontn2kv@active
  # Run enable-kv.sh, create test acounts alice, bob, then nestcontn2kv, before running above 'set contract' command to publish your big size nestcontn2kv.wasm
```
